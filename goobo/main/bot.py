import imp
import os
import socket
import string
import threading
import time
from django.conf import settings

# global socket variable
s = None
stop_goobo = False
CP = settings.COMMAND_PREFIX

class GooBo():
    def send_message(self, recipient, message):
        """
            Sends a one line message to channel/nick in IRC
        """
        time.sleep(settings.MESSAGE_DELAY_TIME)
        s.send('PRIVMSG %s :%s\r\n' % (recipient, message))
    
    
    def _is_channel(self, name):
        """determine if a name represents a channel"""
        return name.startswith("#")
    
    
    def _get_message_info(self, raw_message):
        """
            return (sender, command, recipient, message),
            i.e. discarding the part that generated by IRC automatically.
            An message example:
             ":yournick!~yournick@reverse_ip PRIVMSG #yournick-test :goobo help!"
             print _get_message_info(message)
             >>("yournick", "PRIVMSG", "#yournick-test", "goobo help!")
        """
        try:
            parts = raw_message.split()
            sender = parts[0].split("!")[0][1:]
            command = parts[1]
            recipient = parts[2]
            message = " ".join(parts[3:])[1:]
        except:
            return (None, None, None, None)
        return (sender, command, recipient, message)
    
    
    def _set_up_goobo(self):
        """
            Initialize goobo for all the channels
        """
        self._load_modules()
    
        global s
        global stop_goobo
        s = socket.socket()
        stop_goobo = False
    
        s.connect((settings.HOST, settings.PORT))
    
        # MUST send NICK and USER commands before any other commands
        s.send("NICK %s\r\n" % settings.NICK)
        s.send("USER %s %s bla :%s\r\n" %
               (settings.IDENT, settings.HOST, settings.REALNAME))
    
        #identify nickname
        s.send("NICKSERV IDENTIFY {nick} {password}\r\n"
               .format(nick=settings.NICK,
                       password=settings.FREENODE_NICKNAME_PASSWORD))
    
        #join the CHANNELs
        for channel in settings.CHANNEL_LIST:
            time.sleep(1)
            s.send('JOIN #%s\r\n' % channel)
    
    
    def _quit_goobo(self, channel):
        """
            quit goobo
        """
        send_message(channel, "Who dare to kill me?")
        time.sleep(2)
        send_message(channel, "Well, who dares wins.")
        time.sleep(1)
        s.close()
    
    
    def _tear_down_goobo(self):
        """
            Tear down goobo after quiting
        """
        pass
    
    
    def _ping_pong(self, line):
        """PONG message back upon receiving PING"""
        #  Ping message sent by server irc.funet.fi example:
        #      PING :irc.funet.fi
        print line
        if line.startswith("PING :"):
            s.send("PONG {}\r\n".format(line.split()[1][1:]))
            return True
        return False
    
    def start_goobo(self):
        """
        Start GooBo
        """
        listen_IRC_thread = threading.Thread(target=self._listen_IRC)
        listen_IRC_thread.start()
    
    
    def stop_goobo(self):
        """
        Stop GooBo
        """
        global stop_goobo
        stop_goobo = True
    
    
    def _listen_IRC(self):
        """
            make GooBo keep listening on IRC
        """
        self._set_up_goobo()
    
        global stop_goobo
        # keep listening and acting to commands until receiving QUIT_COMMAND
        readbuffer = ""
        while not stop_goobo:
            readbuffer = readbuffer+s.recv(1024)
            temp = string.split(readbuffer, "\n")
            readbuffer = temp.pop()
    
            for line in temp:
                if self._ping_pong(line):
                    continue
                sender, command, recipient, message = self._get_message_info(line)
                # only reacts on private messages(from channel or nick)
                if command != "PRIVMSG":
                    continue
    
                if self._is_channel(recipient) and not message.startswith(CP):
                    from main.auto_reply import keyword_react
                    keyword_react(GooBo(), recipient, message)
                    continue
    
                # channel message started with GooBo: or private message to GooBo.
                reply_to = sender
                # channel message need to reply to receipt normally
                if self._is_channel(recipient):
                    reply_to = recipient
                # NOTE: GooBo: is not necessary prefix as private message
                command_str = message.replace(settings.COMMAND_PREFIX, "", 1)
                command_parts = command_str.split()
                if not command_parts:
                    send_message(recipient, "Command List: {}help".format(CP))
                    continue
                if command_parts[0] == settings.QUIT_COMMAND:
                    self._quit_goobo(reply_to)
                    stop_goobo = True
                    break
                if command_parts[0] == "echo":
                    from main.echo import echo
                    echo(command_str.replace("echo", "", 1))
                    break
                try:
                    self._dispatch(reply_to, command_str)
                except:
                    pass
    
        self._tear_down_goobo()
    
    
    def _dispatch(self, reply_to, command_str):
        """
            dispatch to corresponding callable
        """
        command_parts = command_str.split()
        command = command_parts[0]
        if command in self.service_list:
            command_params = command_str.replace(command, "", 1).strip()
            self.service_list[command](reply_to, command_params)
    
    
    # supporting dynamically module loading
    files = {}
    modules = []
    service_list = {}
    
    
    def _get_files(self):
        """
            find all the files
        """
        # First, add modules from the regular modules directory
        this_dir = os.path.dirname(os.path.abspath(__file__))
        for fn in os.listdir(this_dir):
            if fn.endswith('.py') and not fn.startswith('_'):
                self.files[fn[:-3]] = os.path.join(this_dir, fn)
    
    
    def _load_modules(self):
        """
            load all the modules
        """
        self._get_files()
        for name, filename in self.files.iteritems():
            try:
                module = imp.load_source(name, filename)
                self._register(vars(module))
                self.modules.append(name)
            except Exception:
                pass
    
    
    def _register(self, variables):
        """
            register all the callables from all the modules
        """
        for obj in variables.itervalues():
            if self._is_callable(obj):
                self.service_list[obj.command] = obj
    
    
    def _is_callable(self, obj):
        """Return true if object is a goobo callable.
        """
        if not callable(obj):
            return False
        if hasattr(obj, 'command'):
            return True
        return False


if __name__ == "__main__":
    goobo = GooBo()
    goobo.start_goobo()
